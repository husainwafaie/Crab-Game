<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underwater Crab Adventure</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const crab = {
            x: 50,
            y: canvas.height - 100,
            width: 60,
            height: 40,
            speed: 5
        };

        let obstacles = [];
        let score = 0;
        let gameOver = false;
        let gameSpeed = 3; // Increased initial game speed

        const bubbles = Array(20).fill().map(() => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: Math.random() * 5 + 2,
            speed: Math.random() * 2 + 1
        }));

        function drawCrab() {
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.ellipse(crab.x + 30, crab.y + 20, 30, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(crab.x + 45, crab.y + 15, 5, 0, Math.PI * 2);
            ctx.arc(crab.x + 45, crab.y + 25, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#FF6347';
            ctx.beginPath();
            ctx.moveTo(crab.x, crab.y + 15);
            ctx.lineTo(crab.x + 20, crab.y + 5);
            ctx.lineTo(crab.x + 20, crab.y + 25);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(crab.x, crab.y + 25);
            ctx.lineTo(crab.x + 20, crab.y + 15);
            ctx.lineTo(crab.x + 20, crab.y + 35);
            ctx.closePath();
            ctx.fill();
        }

        function drawSeaweed(obstacle) {
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.moveTo(obstacle.x, canvas.height);
            for (let i = 0; i < 3; i++) {
                ctx.quadraticCurveTo(
                    obstacle.x + 25 * Math.sin(i * 0.5 + obstacle.x * 0.1),
                    canvas.height - (i + 1) * obstacle.height / 3,
                    obstacle.x,
                    canvas.height - (i + 1) * obstacle.height / 3
                );
            }
            ctx.lineTo(obstacle.x + obstacle.width, canvas.height - obstacle.height);
            ctx.lineTo(obstacle.x + obstacle.width, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Draw highlights
            ctx.strokeStyle = '#32CD32';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(obstacle.x + 10, canvas.height);
            for (let i = 0; i < 3; i++) {
                ctx.quadraticCurveTo(
                    obstacle.x + 35 * Math.sin(i * 0.5 + obstacle.x * 0.1),
                    canvas.height - (i + 1) * obstacle.height / 3,
                    obstacle.x + 10,
                    canvas.height - (i + 1) * obstacle.height / 3
                );
            }
            ctx.stroke();
        }

        function drawStarfish(obstacle) {
            const centerX = obstacle.x + obstacle.width / 2;
            const centerY = obstacle.y + obstacle.height / 2;
            const outerRadius = obstacle.width / 2;
            const innerRadius = outerRadius / 2;

            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const outerAngle = i * 4 * Math.PI / 5;
                const innerAngle = outerAngle + Math.PI / 5;
                
                ctx.lineTo(
                    centerX + Math.cos(outerAngle) * outerRadius,
                    centerY + Math.sin(outerAngle) * outerRadius
                );
                ctx.lineTo(
                    centerX + Math.cos(innerAngle) * innerRadius,
                    centerY + Math.sin(innerAngle) * innerRadius
                );
            }
            ctx.closePath();

            ctx.fillStyle = '#FF69B4';
            ctx.fill();
            ctx.strokeStyle = '#FF1493';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Add texture
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = i * 4 * Math.PI / 5;
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * outerRadius,
                    centerY + Math.sin(angle) * outerRadius
                );
            }
            ctx.strokeStyle = '#FF69B4';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawJellyfish(obstacle) {
            const centerX = obstacle.x + obstacle.width / 2;
            const centerY = obstacle.y + obstacle.height / 2;
            
            // Draw body
            ctx.beginPath();
            ctx.moveTo(centerX - obstacle.width / 2, centerY);
            ctx.quadraticCurveTo(centerX, centerY - obstacle.height / 2, centerX + obstacle.width / 2, centerY);
            ctx.quadraticCurveTo(centerX, centerY + obstacle.height / 4, centerX - obstacle.width / 2, centerY);
            ctx.fillStyle = 'rgba(255, 182, 193, 0.7)';
            ctx.fill();

            // Draw tentacles
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const startX = centerX - obstacle.width / 2 + (i + 1) * obstacle.width / 6;
                ctx.moveTo(startX, centerY);
                ctx.quadraticCurveTo(
                    startX + 10 * Math.sin(Date.now() * 0.01 + i),
                    centerY + obstacle.height / 2,
                    startX + 5 * Math.sin(Date.now() * 0.01 + i),
                    centerY + obstacle.height
                );
            }
            ctx.strokeStyle = 'rgba(255, 105, 180, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                switch(obstacle.type) {
                    case 'seaweed':
                        drawSeaweed(obstacle);
                        break;
                    case 'starfish':
                        drawStarfish(obstacle);
                        break;
                    case 'jellyfish':
                        drawJellyfish(obstacle);
                        break;
                }
            });
        }

        function moveObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
            });

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 200) {
                const obstacleTypes = ['seaweed', 'starfish', 'jellyfish'];
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                let newObstacle;

                switch(type) {
                    case 'seaweed':
                        newObstacle = {
                            x: canvas.width,
                            y: canvas.height - 70,  // Place seaweed at the bottom, above the increased sand height
                            width: 50,
                            height: 150 + Math.random() * 100,
                            type: 'seaweed'
                        };
                        break;
                    case 'starfish':
                        newObstacle = {
                            x: canvas.width,
                            y: Math.random() * (canvas.height - 170) + 10,  // Adjust for bigger starfish
                            width: 100,  // Increased starfish width
                            height: 100,  // Increased starfish height
                            type: 'starfish'
                        };
                        break;
                    case 'jellyfish':
                        newObstacle = {
                            x: canvas.width,
                            y: Math.random() * (canvas.height - 200),
                            width: 80,
                            height: 100,
                            type: 'jellyfish'
                        };
                        break;
                }
                obstacles.push(newObstacle);
            }

            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
        }

        function checkCollision() {
            return obstacles.some(obstacle => {
                let crabHitbox = {
                    x: crab.x + 10,
                    y: crab.y + 10,
                    width: crab.width - 20,
                    height: crab.height - 20
                };

                let obstacleHitbox = {
                    x: obstacle.x,
                    y: obstacle.y,
                    width: obstacle.width,
                    height: obstacle.height
                };

                if (obstacle.type === 'seaweed') {
                    obstacleHitbox.y = canvas.height - obstacle.height;
                }

                return crabHitbox.x < obstacleHitbox.x + obstacleHitbox.width &&
                       crabHitbox.x + crabHitbox.width > obstacleHitbox.x &&
                       crabHitbox.y < obstacleHitbox.y + obstacleHitbox.height &&
                       crabHitbox.y + crabHitbox.height > obstacleHitbox.y;
            });
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`Score: ${score}`, 20, 40);
        }

        function drawBackground() {
            ctx.fillStyle = '#F4A460';
            ctx.fillRect(0, canvas.height - 70, canvas.width, 70);  // Increased sand height to 70px

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            bubbles.forEach(bubble => {
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.fill();

                bubble.y -= bubble.speed;
                if (bubble.y + bubble.radius < 0) {
                    bubble.y = canvas.height + bubble.radius;
                    bubble.x = Math.random() * canvas.width;
                }
            });
        }

        function updateDifficulty() {
            gameSpeed = 3 + Math.floor(score / 500) * 0.5; // Adjusted base speed
            crab.speed = 6 + Math.floor(score / 1000); // Increased crab speed
        }

        function gameLoop() {
            if (gameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawCrab();
            drawObstacles();
            moveObstacles();
            drawScore();
            updateDifficulty();

            if (checkCollision()) {
                gameOver = true;
                showGameOver();
            } else {
                score++;
            }

            requestAnimationFrame(gameLoop);
        }

        function showGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Arial';
            ctx.fillText('Game Over!', canvas.width / 2 - 120, canvas.height / 2 - 50);
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2 - 70, canvas.height / 2);
            
            // Draw retry button
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(canvas.width / 2 - 60, canvas.height / 2 + 30, 120, 40);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('Retry', canvas.width / 2 - 25, canvas.height / 2 + 55);
        }

        function resetGame() {
            obstacles = [];
            score = 0;
            gameOver = false;
            gameSpeed = 3;
            crab.y = canvas.height - 100;
            gameLoop();
        }

        canvas.addEventListener('click', (event) => {
            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Check if click is within retry button
                if (x > canvas.width / 2 - 60 && x < canvas.width / 2 + 60 &&
                    y > canvas.height / 2 + 30 && y < canvas.height / 2 + 70) {
                    resetGame();
                }
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp' && crab.y > 0) {
                crab.y -= crab.speed;
            } else if (event.key === 'ArrowDown' && crab.y < canvas.height - crab.height - 70) {  // Adjusted for new sand height
                crab.y += crab.speed;
            }
        });

        gameLoop();
    </script>
</body>
</html>